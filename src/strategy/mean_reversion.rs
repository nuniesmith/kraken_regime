//! Mean Reversion Strategy using Bollinger Bands
//! 
//! Works best in ranging/mean-reverting market regimes.
//! Buys when price touches lower band, sells when it touches upper band.

use crate::regime::indicators::{BollingerBands, BollingerBandsValues, EMA, ATR};
use serde::{Deserialize, Serialize};

/// Signal generated by the strategy
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Signal {
    Buy,
    Sell,
    Hold,
}

/// Configuration for mean reversion strategy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MeanReversionConfig {
    /// Bollinger Bands period
    pub bb_period: usize,
    /// Bollinger Bands standard deviation multiplier
    pub bb_std_dev: f64,
    
    /// Entry threshold - how close to band before considering entry
    /// 0.05 = price within 5% of band width from the band
    pub entry_threshold: f64,
    
    /// Exit at middle band (SMA) or opposite band
    pub exit_at_middle: bool,
    
    /// RSI period for confirmation
    pub rsi_period: usize,
    /// RSI oversold threshold for buy confirmation
    pub rsi_oversold: f64,
    /// RSI overbought threshold for sell confirmation
    pub rsi_overbought: f64,
    
    /// Require RSI confirmation
    pub require_rsi_confirmation: bool,
    
    /// ATR multiplier for stop loss
    pub atr_stop_multiplier: f64,
    
    /// Minimum band width (as % of price) to trade
    /// Avoids trading in squeeze conditions
    pub min_band_width_pct: f64,
}

impl Default for MeanReversionConfig {
    fn default() -> Self {
        Self {
            bb_period: 20,
            bb_std_dev: 2.0,
            entry_threshold: 0.05,
            exit_at_middle: true,  // More conservative - exit at mean
            rsi_period: 14,
            rsi_oversold: 30.0,
            rsi_overbought: 70.0,
            require_rsi_confirmation: false,
            atr_stop_multiplier: 2.0,
            min_band_width_pct: 2.0,
        }
    }
}

impl MeanReversionConfig {
    /// Aggressive config for crypto - wider entries, exits at opposite band
    pub fn crypto_aggressive() -> Self {
        Self {
            bb_period: 20,
            bb_std_dev: 2.0,
            entry_threshold: 0.10,  // Earlier entry
            exit_at_middle: false,  // Exit at opposite band for bigger moves
            rsi_period: 14,
            rsi_oversold: 35.0,
            rsi_overbought: 65.0,
            require_rsi_confirmation: false,
            atr_stop_multiplier: 2.5,
            min_band_width_pct: 1.5,
        }
    }
    
    /// Conservative config - requires more confirmation
    pub fn conservative() -> Self {
        Self {
            bb_period: 20,
            bb_std_dev: 2.5,
            entry_threshold: 0.02,  // Tighter - really at the band
            exit_at_middle: true,
            rsi_period: 14,
            rsi_oversold: 25.0,
            rsi_overbought: 75.0,
            require_rsi_confirmation: true,
            atr_stop_multiplier: 1.5,
            min_band_width_pct: 3.0,
        }
    }
}

/// RSI calculator
#[derive(Debug, Clone)]
struct RSI {
    period: usize,
    gains: EMA,
    losses: EMA,
    prev_close: Option<f64>,
}

impl RSI {
    fn new(period: usize) -> Self {
        Self {
            period,
            gains: EMA::new(period),
            losses: EMA::new(period),
            prev_close: None,
        }
    }
    
    fn update(&mut self, close: f64) -> Option<f64> {
        if let Some(prev) = self.prev_close {
            let change = close - prev;
            let gain = if change > 0.0 { change } else { 0.0 };
            let loss = if change < 0.0 { -change } else { 0.0 };
            
            if let (Some(avg_gain), Some(avg_loss)) = (
                self.gains.update(gain),
                self.losses.update(loss),
            ) {
                self.prev_close = Some(close);
                
                if avg_loss == 0.0 {
                    return Some(100.0);
                }
                
                let rs = avg_gain / avg_loss;
                let rsi = 100.0 - (100.0 / (1.0 + rs));
                return Some(rsi);
            }
        }
        
        self.prev_close = Some(close);
        None
    }
    
    fn is_ready(&self) -> bool {
        self.gains.is_ready() && self.losses.is_ready()
    }
}

/// Mean Reversion Strategy
#[derive(Debug)]
pub struct MeanReversionStrategy {
    config: MeanReversionConfig,
    
    bb: BollingerBands,
    rsi: RSI,
    atr: ATR,
    
    // Position tracking
    in_position: bool,
    entry_price: Option<f64>,
    entry_side: Option<Signal>,  // Buy or Sell that got us in
    stop_loss: Option<f64>,
    take_profit: Option<f64>,
    
    // Last values for state inspection
    last_bb: Option<BollingerBandsValues>,
    last_rsi: Option<f64>,
    last_signal: Signal,
}

impl MeanReversionStrategy {
    pub fn new(config: MeanReversionConfig) -> Self {
        Self {
            bb: BollingerBands::new(config.bb_period, config.bb_std_dev),
            rsi: RSI::new(config.rsi_period),
            atr: ATR::new(14),
            config,
            in_position: false,
            entry_price: None,
            entry_side: None,
            stop_loss: None,
            take_profit: None,
            last_bb: None,
            last_rsi: None,
            last_signal: Signal::Hold,
        }
    }
    
    /// Create with default config
    pub fn default_config() -> Self {
        Self::new(MeanReversionConfig::default())
    }
    
    /// Update with OHLC data and get signal
    pub fn update(&mut self, high: f64, low: f64, close: f64) -> Signal {
        // Update indicators
        let bb_values = self.bb.update(close);
        let rsi_value = self.rsi.update(close);
        let atr_value = self.atr.update(high, low, close);
        
        self.last_bb = bb_values;
        self.last_rsi = rsi_value;
        
        // Check if ready
        if bb_values.is_none() {
            return Signal::Hold;
        }
        
        let bb = bb_values.unwrap();
        
        // Check for stop loss / take profit if in position
        if self.in_position {
            if let Some(signal) = self.check_exit_conditions(close, &bb) {
                self.exit_position();
                self.last_signal = signal;
                return signal;
            }
        }
        
        // Check band width - avoid trading in squeeze
        if bb.width < self.config.min_band_width_pct {
            self.last_signal = Signal::Hold;
            return Signal::Hold;
        }
        
        // Generate entry signals
        let signal = if !self.in_position {
            self.check_entry_conditions(close, &bb, rsi_value, atr_value)
        } else {
            Signal::Hold
        };
        
        self.last_signal = signal;
        signal
    }
    
    fn check_entry_conditions(
        &mut self,
        close: f64,
        bb: &BollingerBandsValues,
        rsi: Option<f64>,
        atr: Option<f64>,
    ) -> Signal {
        // Check for oversold (buy signal)
        if bb.percent_b <= self.config.entry_threshold {
            // RSI confirmation if required
            if self.config.require_rsi_confirmation {
                if let Some(rsi_val) = rsi {
                    if rsi_val > self.config.rsi_oversold {
                        return Signal::Hold;  // RSI not confirming
                    }
                } else {
                    return Signal::Hold;  // RSI not ready
                }
            }
            
            // Set up position
            self.enter_position(close, Signal::Buy, bb, atr);
            return Signal::Buy;
        }
        
        // Check for overbought (sell signal) - for short selling
        // In spot trading (long only), this would be an exit signal
        if bb.percent_b >= (1.0 - self.config.entry_threshold) {
            if self.config.require_rsi_confirmation {
                if let Some(rsi_val) = rsi {
                    if rsi_val < self.config.rsi_overbought {
                        return Signal::Hold;
                    }
                } else {
                    return Signal::Hold;
                }
            }
            
            // In spot mode, we only sell if we have a position
            // This would trigger if we're tracking existing positions elsewhere
            self.enter_position(close, Signal::Sell, bb, atr);
            return Signal::Sell;
        }
        
        Signal::Hold
    }
    
    fn enter_position(
        &mut self, 
        price: f64, 
        side: Signal, 
        bb: &BollingerBandsValues,
        atr: Option<f64>,
    ) {
        self.in_position = true;
        self.entry_price = Some(price);
        self.entry_side = Some(side);
        
        // Set stop loss using ATR
        let atr_val = atr.unwrap_or(price * 0.02);  // Default 2% if no ATR
        let stop_distance = atr_val * self.config.atr_stop_multiplier;
        
        match side {
            Signal::Buy => {
                self.stop_loss = Some(price - stop_distance);
                self.take_profit = if self.config.exit_at_middle {
                    Some(bb.middle)
                } else {
                    Some(bb.upper)
                };
            }
            Signal::Sell => {
                self.stop_loss = Some(price + stop_distance);
                self.take_profit = if self.config.exit_at_middle {
                    Some(bb.middle)
                } else {
                    Some(bb.lower)
                };
            }
            _ => {}
        }
    }
    
    fn check_exit_conditions(&self, close: f64, bb: &BollingerBandsValues) -> Option<Signal> {
        match self.entry_side {
            Some(Signal::Buy) => {
                // Exit long position
                if let Some(stop) = self.stop_loss {
                    if close <= stop {
                        return Some(Signal::Sell);  // Stop loss hit
                    }
                }
                
                // Take profit
                if self.config.exit_at_middle && close >= bb.middle {
                    return Some(Signal::Sell);
                }
                if !self.config.exit_at_middle && bb.percent_b >= 0.95 {
                    return Some(Signal::Sell);
                }
            }
            Some(Signal::Sell) => {
                // Exit short position
                if let Some(stop) = self.stop_loss {
                    if close >= stop {
                        return Some(Signal::Buy);  // Stop loss hit
                    }
                }
                
                // Take profit
                if self.config.exit_at_middle && close <= bb.middle {
                    return Some(Signal::Buy);
                }
                if !self.config.exit_at_middle && bb.percent_b <= 0.05 {
                    return Some(Signal::Buy);
                }
            }
            _ => {}
        }
        
        None
    }
    
    fn exit_position(&mut self) {
        self.in_position = false;
        self.entry_price = None;
        self.entry_side = None;
        self.stop_loss = None;
        self.take_profit = None;
    }
    
    // Getters for state inspection
    
    pub fn is_ready(&self) -> bool {
        self.bb.is_ready()
    }
    
    pub fn is_in_position(&self) -> bool {
        self.in_position
    }
    
    pub fn last_bb_values(&self) -> Option<&BollingerBandsValues> {
        self.last_bb.as_ref()
    }
    
    pub fn last_rsi(&self) -> Option<f64> {
        self.last_rsi
    }
    
    pub fn entry_price(&self) -> Option<f64> {
        self.entry_price
    }
    
    pub fn stop_loss(&self) -> Option<f64> {
        self.stop_loss
    }
    
    pub fn take_profit(&self) -> Option<f64> {
        self.take_profit
    }
    
    pub fn config(&self) -> &MeanReversionConfig {
        &self.config
    }
}

/// Result from strategy update, including reasoning
#[derive(Debug, Clone)]
pub struct StrategyResult {
    pub signal: Signal,
    pub bb_values: Option<BollingerBandsValues>,
    pub rsi: Option<f64>,
    pub reason: String,
}

impl MeanReversionStrategy {
    /// Update with detailed reasoning
    pub fn update_with_reason(&mut self, high: f64, low: f64, close: f64) -> StrategyResult {
        let signal = self.update(high, low, close);
        
        let reason = match signal {
            Signal::Buy => format!(
                "Buy: Price at lower BB ({}), %B={:.2}", 
                self.last_bb.as_ref().map(|b| format!("{:.2}", b.lower)).unwrap_or_default(),
                self.last_bb.as_ref().map(|b| b.percent_b).unwrap_or(0.0)
            ),
            Signal::Sell => format!(
                "Sell: Price at upper BB ({}), %B={:.2}",
                self.last_bb.as_ref().map(|b| format!("{:.2}", b.upper)).unwrap_or_default(),
                self.last_bb.as_ref().map(|b| b.percent_b).unwrap_or(0.0)
            ),
            Signal::Hold => "Hold: No signal".to_string(),
        };
        
        StrategyResult {
            signal,
            bb_values: self.last_bb,
            rsi: self.last_rsi,
            reason,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_mean_reversion_buy_signal() {
        let mut strategy = MeanReversionStrategy::default_config();
        
        // Warm up with stable prices
        for _ in 0..25 {
            strategy.update(100.0, 99.0, 99.5);
        }
        
        // Price drops to lower band
        for _ in 0..5 {
            strategy.update(96.0, 94.0, 95.0);
        }
        
        // Should eventually generate buy signal at lower band
        let signal = strategy.update(93.0, 91.0, 92.0);
        println!("Signal: {:?}, %B: {:?}", signal, strategy.last_bb.as_ref().map(|b| b.percent_b));
    }
    
    #[test]
    fn test_strategy_respects_band_width() {
        let config = MeanReversionConfig {
            min_band_width_pct: 5.0,  // High threshold
            ..Default::default()
        };
        let mut strategy = MeanReversionStrategy::new(config);
        
        // Feed tight range data
        for i in 0..30 {
            let price = 100.0 + (i as f64 % 2.0) * 0.1;  // Very tight range
            strategy.update(price + 0.05, price - 0.05, price);
        }
        
        // Should not generate signals due to narrow bands
        let signal = strategy.update(99.5, 99.3, 99.4);
        assert_eq!(signal, Signal::Hold);
    }
}
